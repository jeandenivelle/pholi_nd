
%dir calc
%namespace calc

%define proofterm ( prf_nop ) 

%option propcut { prf_propcut } => fm : logic::term
%option cut { prf_cut } => ind : ssize_t 

%option chain { prf_chain } => [ step : proofterm ] 
%option nop { prf_nop } => 

%option flatten { prf_flatten } => ind : ssize_t 

%option copy { prf_copy } => level : std::string, ind : ssize_t
%option erase { prf_erase } => ind : ssize_t

%option orexistselim { prf_orexistselim } => ind : ssize_t, 
   name : std::string, [ branch : proofterm ] 

%option expand { prf_expand } => 
   ind : ssize_t, ident : identifier, occ : size_t 

%option expandlocal { prf_expandlocal } => 
   ind : ssize_t, name : std::string, occ : size_t
%option betapi { prf_betapi } => ind : ssize_t

%option forallintro { prf_forallintro } =>
   parent : proofterm, [ var : logic::vartype ]
%option forallelim { prf_forallelim } => 
   ind : ssize_t, [ value : logic::term ] 

%option define { prf_define } =>
   name : std::string, val : logic::term, parent : proofterm

%option simplify { prf_simplify } => 
   // Always the complete toplevel.

%option fake { prf_fake } => goal : logic::term
%option show { prf_show } => comment : std::string

%h_incl {
   #include "sequent.h"
}

%h_before {
   bool very_equal( const std::vector< logic::term > & v1, const std::vector< logic::term > & v2 );
}

%h_methods {

   void print( indentation ind, std::ostream& out ) const;
}


%cpp_back
{
   void calc::proofterm::print( indentation ind, std::ostream& out ) const
   {
      switch( sel( ))
      {
//      case prf_truthconst:
//         out << ind << "truthconst\n";
//         return; 

//      case prf_ident:
//         out << ind << "ident " << view_ident( ). ident( ) << "\n"; 
//         return; 

      case prf_propcut:
         out << ind << "propcut: " << view_propcut( ). fm( ) << "\n";
         return;

     case prf_cut:
        out << ind << "cut " << view_cut( ). ind( ) << "\n";
        return;

      case prf_chain: 
         {
            out << ind << "chain\n";
            auto ch = view_chain( );
            for( size_t i = 0; i != ch. size( ); ++ i )
               ch. step(i). print( ind + 3, out );
            return;
         }

      case prf_nop:
         out << ind << "nop\n";
         return;

      case prf_flatten:
         out << ind << "flatten " << view_flatten( ). ind( ) << "\n";
         return; 

      case prf_orexistselim:
         {
            auto elim = view_orexistselim( ); 
            out << ind << "orexistselim\n";
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               out << ind << "branch " << i << ":\n";
               elim. branch(i). print( ind + 3, out );
            }
            return;
         }

      case prf_expand:
         {
            auto exp = view_expand( );
            out << ind << "expand ";
            out << exp. ident( ) << "/" << exp. occ( );
            out << " in " << exp. ind( ) << "\n";
            return;  
         }

      case prf_expandlocal:
         {
            auto exp = view_expandlocal( );
            out << ind << "expandlocal ";
            out << exp. name( ) << "/" << exp. occ( );
            out << " in " << exp. ind( ) << "\n";
            return;
         }

      case prf_betapi:
         {
            out << ind << "pibeta" << view_betapi( ). ind( ) << "\n";
            return;
         }

      case prf_copy:
         {
            auto copy = view_copy( );
            out << ind << "copy " << copy. level( );
            out << '[' << copy. ind( ) << "]\n";
            return;
         }

      case prf_define:
         {
            auto def = view_define( );
            out << ind << "define ";
            out << def. name( ) << " := " << def. val( ) << "\n";
            out << ind << "in\n";
            def. parent( ). print( ind + 3, out );
            return;
         }

      case prf_forallintro:
         {
            auto intro = view_forallintro( );
            out << ind << "forallintro with";
            for( size_t i = 0; i != intro. size( ); ++ i )
            {
               if(i)
                  out << ", ";
               out << intro. var(i);
            }
            out << "\n";
            intro. parent( ). print( ind + 3, out );
            return; 
         }
 
      case prf_forallelim:
         {
            auto elim = view_forallelim( );
            out << ind << "forallelim with ";
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               if(i) out << ",  ";
               out << elim. value(i) << "\n";
            }
            out << " in " << elim. ind( ) << "\n";
            return;
         }

      case prf_simplify:
         {
            out << ind << "simplify\n";
            return;
         }

      case prf_fake:
         {
            out << ind << "faking ";
            auto mag = view_fake( );
            out << mag. goal( ) << "\n";
            return;
         }

      case prf_show:
         {
            auto show = view_show( );
            out << ind << "show as ";
            out << "\"" << show. comment( ) << "\"\n";
            return;
         }
      }

      out << sel( ) << "\n";
      throw std::logic_error( "don't know how to print" );
   }

}

 
